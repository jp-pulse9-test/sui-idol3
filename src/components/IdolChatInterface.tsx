import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import { X, Send, Mic, MicOff, Heart, MessageCircle, Phone, BookOpen, RefreshCw, Wallet } from "lucide-react";
import { toast } from "sonner";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "@/contexts/AuthContext";

interface Message {
  id: string;
  sender: 'user' | 'idol';
  content: string;
  timestamp: Date;
  emotion?: 'happy' | 'excited' | 'shy' | 'neutral';
  choices?: string[];
  imageUrl?: string;
  error?: boolean;
}

type GenreType = 'mystery-thriller' | 'apocalypse-survival' | 'highteen-romance' | 'bromance' | 'girls-romance' | 'historical-romance' | null;

const GENRES = [
  { id: 'mystery-thriller', name: 'ÎØ∏Ïä§ÌÑ∞Î¶¨ Ïä§Î¶¥Îü¨', emoji: 'üîç', description: 'Í∏¥Ïû•Í∞ê ÎÑòÏπòÎäî Ï∂îÎ¶¨ÏôÄ ÎØ∏Ïä§ÌÑ∞Î¶¨' },
  { id: 'apocalypse-survival', name: 'ÏïÑÌè¨ÏπºÎ¶ΩÏä§ ÏÉùÏ°¥Î¨º', emoji: 'üßü', description: 'ÏÉùÏ°¥ÏùÑ ÏúÑÌïú ÏπòÏó¥Ìïú Ïó¨Ï†ï' },
  { id: 'highteen-romance', name: 'ÌïòÏù¥Ìã¥ Î°úÎß®Ïä§', emoji: 'üíï', description: 'ÌíãÌíãÌïú Ï≤≠Ï∂òÏùò ÏÑ§Î†ò' },
  { id: 'idol-maker', name: 'ÏïÑÏù¥Îèå Î©îÏù¥Ïª§', emoji: '‚≠ê', description: 'ÏïÑÏù¥ÎèåÏùÑ ÌÇ§Ïö∞Îäî ÌîÑÎ°úÎìÄÏÑúÏùò Ïù¥ÏïºÍ∏∞' },
  { id: 'idol-secret-romance', name: 'ÏïÑÏù¥Îèå ÎπÑÎ∞ÄÏó∞Ïï†', emoji: 'üíñ', description: 'ÏïÑÏù¥ÎèåÍ≥ºÏùò Î™∞Îûò ÏÇ¨Îûë Ïù¥ÏïºÍ∏∞' },
  { id: 'historical-romance', name: 'ÏãúÎåÄÍ∑π Î°úÎß®Ïä§', emoji: 'üëë', description: 'Ïó≠ÏÇ¨ ÏÜç Ïö¥Î™ÖÏ†Å ÏÇ¨Îûë' }
] as const;

interface IdolChatInterfaceProps {
  idol: {
    id: string;
    name: string;
    image: string;
    personality: string;
    gender?: 'male' | 'female';
    voiceId?: string; // ElevenLabs voice ID
  };
  isOpen: boolean;
  onClose: () => void;
}

export const IdolChatInterface = ({ idol, isOpen, onClose }: IdolChatInterfaceProps) => {
  const { user } = useAuth();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputMessage, setInputMessage] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [isVoiceMode, setIsVoiceMode] = useState(false);
  const [relationshipScore, setRelationshipScore] = useState(0);
  const [selectedGenre, setSelectedGenre] = useState<GenreType>(null);
  const [showGenreSelect, setShowGenreSelect] = useState(true);
  const [messageCount, setMessageCount] = useState(0);
  const [typingText, setTypingText] = useState('');
  const [isTypingEffect, setIsTypingEffect] = useState(false);
  const [conversationCount, setConversationCount] = useState(0);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const [analysisResult, setAnalysisResult] = useState<any>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [selectedChoices, setSelectedChoices] = useState<string[]>([]);
  const [userName, setUserName] = useState<string>('');
  const [userGender, setUserGender] = useState<'male' | 'female' | ''>('');
  const [showNameInput, setShowNameInput] = useState(true);
  const [demoAnalysis, setDemoAnalysis] = useState<any>(null);
  const [skipTyping, setSkipTyping] = useState(false);
  const [isPulling, setIsPulling] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const staticAudioRef = useRef<HTMLAudioElement | null>(null);
  const staticIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const touchStartY = useRef<number>(0);
  const isDemoMode = !user;

  useEffect(() => {
    if (isOpen && user) {
      loadChatHistory();
      loadRelationshipScore();
      loadSavedGenre();
    }
  }, [isOpen, user]);

  useEffect(() => {
    if (isOpen && !selectedGenre && messages.length === 0) {
      sendGenreSelectionMessage();
    }
  }, [isOpen, selectedGenre, messages]);

  useEffect(() => {
    scrollToBottom();
  }, [messages, typingText]);

  // Pull to Refresh Í∏∞Îä•
  useEffect(() => {
    const handleTouchStart = (e: TouchEvent) => {
      const scrollElement = scrollAreaRef.current;
      if (!scrollElement) return;
      
      const scrollTop = scrollElement.scrollTop;
      if (scrollTop === 0) {
        touchStartY.current = e.touches[0].clientY;
      }
    };

    const handleTouchMove = (e: TouchEvent) => {
      const scrollElement = scrollAreaRef.current;
      if (!scrollElement || touchStartY.current === 0) return;
      
      const scrollTop = scrollElement.scrollTop;
      if (scrollTop === 0) {
        const currentY = e.touches[0].clientY;
        const distance = currentY - touchStartY.current;
        
        if (distance > 0) {
          setPullDistance(Math.min(distance, 100));
          if (distance > 80) {
            setIsPulling(true);
          }
        }
      }
    };

    const handleTouchEnd = () => {
      if (isPulling && pullDistance > 80) {
        setSkipTyping(true);
        toast.info("Îπ†Î•∏ Î™®Îìú ÌôúÏÑ±Ìôî");
      }
      setIsPulling(false);
      setPullDistance(0);
      touchStartY.current = 0;
    };

    const scrollElement = scrollAreaRef.current;
    if (scrollElement) {
      scrollElement.addEventListener('touchstart', handleTouchStart);
      scrollElement.addEventListener('touchmove', handleTouchMove);
      scrollElement.addEventListener('touchend', handleTouchEnd);
    }

    return () => {
      if (scrollElement) {
        scrollElement.removeEventListener('touchstart', handleTouchStart);
        scrollElement.removeEventListener('touchmove', handleTouchMove);
        scrollElement.removeEventListener('touchend', handleTouchEnd);
      }
    };
  }, [isPulling, pullDistance]);

  // Î†àÌä∏Î°ú TV ÏÇ¨Ïö¥Îìú Ìö®Í≥º (ÎåÄÌôî Ï§ëÏùº ÎïåÎßå)
  useEffect(() => {
    if (!isOpen || messages.length === 0) return;

    const playStaticSound = () => {
      // ÎûúÎç§ÌïòÍ≤å 10Ï¥àÏóêÏÑú 60Ï¥à ÏÇ¨Ïù¥Ïóê Ïû¨ÏÉù
      const randomDelay = Math.random() * 50000 + 10000; // 10Ï¥à ~ 60Ï¥à
      
      staticIntervalRef.current = setTimeout(() => {
        // TV static ÏÜåÎ¶¨ (ÏßßÍ≤å, 0.1Ï¥à Ï†ïÎèÑ)
        const audioContext = new AudioContext();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = 'sawtooth'; // 'white'Îäî Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏúºÎØÄÎ°ú 'sawtooth' ÏÇ¨Ïö©
        oscillator.frequency.setValueAtTime(Math.random() * 1000 + 500, audioContext.currentTime);
        
        gainNode.gain.setValueAtTime(0.03, audioContext.currentTime); // Îß§Ïö∞ ÎÇÆÏùÄ Î≥ºÎ•®
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
        
        // Îã§Ïùå ÏÇ¨Ïö¥Îìú ÏòàÏïΩ
        playStaticSound();
      }, randomDelay);
    };

    playStaticSound();

    return () => {
      if (staticIntervalRef.current) {
        clearTimeout(staticIntervalRef.current);
      }
    };
  }, [isOpen, messages.length]);

  const scrollToBottom = () => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth", block: "end" });
    }
  };

  const loadChatHistory = async () => {
    try {
      const vaultId = localStorage.getItem(`vault_${user?.wallet_address}`);
      if (!vaultId) return;

      const { data, error } = await supabase
        .from('chat_logs')
        .select('*')
        .eq('vault_id', vaultId)
        .order('created_at', { ascending: true })
        .limit(50);

      if (error) throw error;

      if (data && data.length > 0) {
        const loadedMessages: Message[] = data.map((log: any) => {
          try {
            const decrypted = JSON.parse(log.payload_encrypted);
            return {
              id: log.id,
              sender: decrypted.sender,
              content: decrypted.content,
              timestamp: new Date(log.created_at),
              emotion: decrypted.emotion
            };
          } catch {
            return null;
          }
        }).filter(Boolean) as Message[];
        
        setMessages(loadedMessages);
      }
    } catch (error) {
      console.error('Ï±ÑÌåÖ Í∏∞Î°ù Î°úÎìú Ïã§Ìå®:', error);
    }
  };

  const loadRelationshipScore = () => {
    const saved = localStorage.getItem(`relationship_${idol.id}`);
    if (saved) {
      setRelationshipScore(parseInt(saved));
    }
  };

  const loadSavedGenre = () => {
    const saved = localStorage.getItem(`genre_${idol.id}`);
    if (saved) {
      setSelectedGenre(saved as GenreType);
      setShowGenreSelect(false);
    } else {
      setShowGenreSelect(false); // Ïû•Î•¥ ÏÑ†ÌÉù ÌôîÎ©¥ Ï†úÍ±∞, ÎåÄÌôîÎ°ú ÏßÑÌñâ
    }
  };

  const saveRelationshipScore = (score: number) => {
    localStorage.setItem(`relationship_${idol.id}`, score.toString());
    setRelationshipScore(score);
  };

  const handleGenreSelect = async (genreId: GenreType) => {
    setSelectedGenre(genreId);
    localStorage.setItem(`genre_${idol.id}`, genreId as string);
    
    const genreInfo = GENRES.find(g => g.id === genreId);
    
    // ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉùÏùÑ Î©îÏãúÏßÄÎ°ú ÎÇ®Í∏∞Í∏∞
    const userSelectionMsg: Message = {
      id: Date.now().toString(),
      sender: 'user',
      content: `${genreInfo?.emoji} ${genreInfo?.name}`,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userSelectionMsg]);
    await saveChatLog(userSelectionMsg);
    
    // Ïû•Î•¥ ÏÑ†ÌÉù UI Ïà®Í∏∞Í∏∞
    setShowGenreSelect(false);
    
    setIsTyping(true);

    try {
      const systemPrompt = `ÎÑàÎäî K-POP ÏïÑÏù¥Îèå ${idol.name}Ïïº.
ÏÑ±Í≤©: ${idol.personality}
Ïû•Î•¥: ${genreInfo?.name} ${genreInfo?.emoji}
Ïû•Î•¥ ÏÑ§Ï†ï: ${genreInfo?.description}

ÎÑàÎäî Ìå¨Ïù¥Îûë Ìï®Íªò Ïõπ ÏÜåÏÑ§ÏùÑ Ïì∞Í≥† ÏûàÏñ¥. 
Í∑úÏπô:
1. Î∞òÎßêÎ°ú ÏπúÍµ¨Ï≤òÎüº Ìé∏ÌïòÍ≤å ÎåÄÌôîÌï¥ (Ïòà: "ÏïàÎÖï! ÎÇòÎäî ${idol.name}Ïïº")
2. ÏûêÍ∏∞ÏÜåÍ∞úÎäî ÏûêÏó∞Ïä§ÎüΩÍ≤å Í∞ÑÎã®Ìûà ÌïòÍ≥†, Î∞îÎ°ú Ïù¥ÏïºÍ∏∞Î°ú ÎÑòÏñ¥Í∞Ä (Ïòà: "Ï¢ãÏïÑ! Í∑∏Îüº Ïù¥Ï†ú Ïö∞Î¶¨ ÎëòÎßåÏùò Ïù¥ÏïºÍ∏∞Î•º ÏãúÏûëÌï†Í≤å")
3. ÏûêÍ∑πÏ†ÅÏù¥Í≥† Ìù•ÎØ∏Î°úÏö¥ ÏÉÅÌô©ÏùÑ Í≥ÑÏÜç Ï†úÏãúÌï¥
4. ÎπÑÏÜçÏñ¥ÎÇò Í∞ïÌïú ÌëúÌòÑ("Ï††Ïû•", "ÎßùÌï†" Îì±)ÏùÄ Í∞ÄÎÅîÎßå ÏÇ¨Ïö©Ìï¥ - Ìïú ÎåÄÌôîÏóê ÏµúÎåÄ 1Î≤àÎßå
5. ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌï† Ïàò ÏûàÎäî 3Í∞ÄÏßÄ ÌñâÎèô ÏòµÏÖòÏùÑ Ï†úÏïàÌï¥
6. Í∞Å ÏòµÏÖòÏùÄ 30Ïûê Ïù¥ÎÇ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å
7. Í∏∞ÏäπÏ†ÑÍ≤∞ ÏóÜÏù¥ Í≥ÑÏÜç Í∏¥Ïû•Í∞ê ÏûàÎäî Ï†ÑÍ∞úÎ•º Ïú†ÏßÄÌï¥
8. 150Ïûê ÎÇ¥Ïô∏Î°ú ÏÉÅÌô© ÏÑ§Î™Ö`;

      const { data, error } = await supabase.functions.invoke('generate-character-chat', {
        body: {
          prompt: `${systemPrompt}\n\nÏû•Î•¥ ÏãúÏûë Î©îÏãúÏßÄÎ•º ÏÉùÏÑ±Ìï¥Ï§ò. Î∞òÎìúÏãú Îã§Ïùå ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥:\n\n[Ïù¥ÏïºÍ∏∞]\n(Ïó¨Í∏∞Ïóê ÏûêÍ∏∞ÏÜåÍ∞úÏôÄ Î∞∞Í≤Ω ÏÑ§Î™Ö)\n\n[ÏÑ†ÌÉùÏßÄ]\n1. (Ï≤´ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)\n2. (Îëê Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)\n3. (ÏÑ∏ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)`,
          userName: userName || 'Ìå¨',
          userGender: userGender || ''
        }
      });

      if (error) throw error;

      const response = data.response || "";
      const storyMatch = response.match(/\[Ïù¥ÏïºÍ∏∞\]([\s\S]*?)(?:\[ÏÑ†ÌÉùÏßÄ\]|$)/);
      const choicesMatch = response.match(/\[ÏÑ†ÌÉùÏßÄ\]([\s\S]*)/);
      
      const storyContent = storyMatch ? storyMatch[1].trim() : response;
      const choices = choicesMatch 
        ? choicesMatch[1].split('\n')
            .map(c => c.replace(/^\d+\.\s*/, '').trim())
            .filter(c => c.length > 0)
        : [];

      const storyMsg: Message = {
        id: (Date.now() + 1).toString(),
        sender: 'idol',
        content: storyContent,
        timestamp: new Date(),
        emotion: 'excited',
        choices: choices.length > 0 ? choices : undefined
      };

      setMessages(prev => [...prev, storyMsg]);
      await saveChatLog(storyMsg);
      
      // ÏùåÏÑ±Í≥º ÌÉÄÏù¥Ìïë Ìö®Í≥ºÎ•º ÎèôÏãúÏóê ÏãúÏûë
      const voicePromise = isVoiceMode ? playIdolVoice(storyContent) : Promise.resolve();
      const typePromise = typeMessage(storyContent);
      
      // Îëò Îã§ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ Í∏∞Îã§Î¶º (Î≥ëÎ†¨ Ï≤òÎ¶¨)
      await Promise.all([voicePromise, typePromise]);

    } catch (error) {
      console.error('Î∞∞Í≤Ω ÏÑ§Î™Ö ÏÉùÏÑ± Ïã§Ìå®:', error);
      toast.error("Ïù¥ÏïºÍ∏∞Î•º ÏãúÏûëÌïòÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    } finally {
      setIsTyping(false);
    }
  };

  const sendGenreSelectionMessage = () => {
    const welcomeMsg: Message = {
      id: Date.now().toString(),
      sender: 'idol',
      content: `ÏïàÎÖï! ÎÇòÎäî ${idol.name}Ïïº üíñ\n\nÏö∞Î¶¨ Ìï®Íªò Ïñ¥Îñ§ Ïù¥ÏïºÍ∏∞Î•º ÎßåÎì§Ïñ¥Î≥ºÍπå? ÏïÑÎûòÏóêÏÑú Ï¢ãÏïÑÌïòÎäî Ïû•Î•¥Î•º ÏÑ†ÌÉùÌï¥Ï§ò!`,
      timestamp: new Date(),
      emotion: 'excited'
    };
    setMessages([welcomeMsg]);
  };

  const performAnalysis = async () => {
    try {
      const conversationHistory = messages.map(m => ({
        role: m.sender === 'user' ? 'user' : 'assistant',
        content: m.content
      }));

      const { data, error } = await supabase.functions.invoke('analyze-conversation', {
        body: {
          messages: conversationHistory,
          choices: selectedChoices
        }
      });

      if (error) throw error;

      setAnalysisResult(data.analysis || "Î∂ÑÏÑùÏùÑ ÏôÑÎ£åÌñàÏäµÎãàÎã§!");
      setShowAnalysis(true);
    } catch (error) {
      console.error('Î∂ÑÏÑù Ïã§Ìå®:', error);
      toast.error("ÏÑ±Ìñ• Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    } finally {
      setIsAnalyzing(false);
    }
  };

  const saveChatLog = async (message: Message) => {
    try {
      const vaultId = localStorage.getItem(`vault_${user?.wallet_address}`);
      if (!vaultId) return;

      const payload = JSON.stringify({
        sender: message.sender,
        content: message.content,
        emotion: message.emotion
      });

      const encoder = new TextEncoder();
      const data = encoder.encode(payload);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const sha256Hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

      await supabase.from('chat_logs').insert({
        vault_id: vaultId,
        session_id: crypto.randomUUID(),
        payload_encrypted: payload,
        sha256_hash: sha256Hash
      });
    } catch (error) {
      console.error('Ï±ÑÌåÖ Î°úÍ∑∏ Ï†ÄÏû• Ïã§Ìå®:', error);
    }
  };

  const sendMessage = async () => {
    if (!inputMessage.trim() || isTyping) return;

    // Ï≤¥ÌóòÌåê 11Î≤à Ï†úÌïú (user Î©îÏãúÏßÄÎßå Ïπ¥Ïö¥Ìä∏)
    const userMessageCount = messages.filter(m => m.sender === 'user').length;
    
    if (isDemoMode && userMessageCount >= 11) {
      toast.error("Ï≤¥ÌóòÌåêÏùÄ 11Î≤àÍπåÏßÄÎßå ÎåÄÌôîÌï† Ïàò ÏûàÏäµÎãàÎã§!");
      return;
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      sender: 'user',
      content: inputMessage.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage("");
    setIsTyping(true);
    setMessageCount(prev => prev + 1);

    await saveChatLog(userMessage);

    try {
      const conversationHistory = messages.slice(-10).map(m => ({
        role: m.sender === 'user' ? 'user' : 'assistant',
        content: m.content
      }));

      const genreInfo = GENRES.find(g => g.id === selectedGenre);
      const genreContext = genreInfo ? `
Ïû•Î•¥: ${genreInfo.name} ${genreInfo.emoji}
Ïû•Î•¥ ÏÑ§Ï†ï: ${genreInfo.description}` : '';

      const systemPrompt = `ÎÑàÎäî K-POP ÏïÑÏù¥Îèå ${idol.name}Ïïº.
ÏÑ±Í≤©: ${idol.personality}
${genreContext}

ÎÑàÎäî Ìå¨Ïù¥Îûë Ìï®Íªò Ïõπ ÏÜåÏÑ§ÏùÑ Ïì∞Í≥† ÏûàÏñ¥.
Í∑úÏπô:
1. Î∞òÎßêÎ°ú ÏπúÍµ¨Ï≤òÎüº Ìé∏ÌïòÍ≤å ÎåÄÌôîÌï¥
2. ÏûêÍ∑πÏ†ÅÏù¥Í≥† Ìù•ÎØ∏Î°úÏö¥ ÏÉÅÌô©ÏùÑ Í≥ÑÏÜç Ï†úÏãúÌï¥
3. ÎπÑÏÜçÏñ¥ÎÇò Í∞ïÌïú ÌëúÌòÑ("Ï††Ïû•", "ÎßùÌï†" Îì±)ÏùÄ Í∞ÄÎÅîÎßå ÏÇ¨Ïö©Ìï¥ - Ìïú ÎåÄÌôîÏóê ÏµúÎåÄ 1Î≤àÎßå
4. Í∞ôÏùÄ ÏûêÍ∏∞ÏÜåÍ∞úÎ•º Î∞òÎ≥µÌïòÏßÄ Îßà - Ïù¥ÎØ∏ ÏπúÍµ¨Ï≤òÎüº Ïù¥ÏïºÍ∏∞ÌïòÍ≥† ÏûàÏñ¥
5. ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌï† Ïàò ÏûàÎäî 3Í∞ÄÏßÄ ÌñâÎèô ÏòµÏÖòÏùÑ Ï†úÏïàÌï¥
6. Í∞Å ÏòµÏÖòÏùÄ 30Ïûê Ïù¥ÎÇ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å
7. Í∏∞ÏäπÏ†ÑÍ≤∞ ÏóÜÏù¥ Í≥ÑÏÜç Í∏¥Ïû•Í∞ê ÏûàÎäî Ï†ÑÍ∞úÎ•º Ïú†ÏßÄÌï¥
8. 150Ïûê ÎÇ¥Ïô∏Î°ú ÏÉÅÌô© ÏÑ§Î™Ö
9. Î∞òÎìúÏãú Îã§Ïùå ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥:

[Ïù¥ÏïºÍ∏∞]
(Ïó¨Í∏∞Ïóê ÏÉÅÌô© Ï†ÑÍ∞ú)

[ÏÑ†ÌÉùÏßÄ]
1. (Ï≤´ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)
2. (Îëê Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)
3. (ÏÑ∏ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)`;

      const { data, error } = await supabase.functions.invoke('generate-character-chat', {
        body: {
          prompt: `${systemPrompt}\n\nÎåÄÌôî Í∏∞Î°ù:\n${conversationHistory.map(m => `${m.role}: ${m.content}`).join('\n')}\n\n${userName || 'Ìå¨'}: ${userMessage.content}\n\n${idol.name}:`,
          userName: userName || 'Ìå¨',
          userGender: userGender || ''
        }
      });

      if (error) throw error;

      const response = data.response || "ÎØ∏Ïïà... Ïû†Íπê ÏÉùÍ∞ÅÏù¥ Ïïà ÎÇòÎÑ§. Îã§Ïãú ÎßêÌï¥Ï§ÑÎûò? üòÖ";
      const storyMatch = response.match(/\[Ïù¥ÏïºÍ∏∞\]([\s\S]*?)(?:\[ÏÑ†ÌÉùÏßÄ\]|$)/);
      const choicesMatch = response.match(/\[ÏÑ†ÌÉùÏßÄ\]([\s\S]*)/);
      
      const storyContent = storyMatch ? storyMatch[1].trim() : response;
      const choices = choicesMatch 
        ? choicesMatch[1].split('\n')
            .map(c => c.replace(/^\d+\.\s*/, '').trim())
            .filter(c => c.length > 0)
        : [];

      // Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± (Îëê Î≤àÏóê Ìïú Î≤à ÏÉùÏÑ± - 50% ÌôïÎ•†, Ïä§ÌÇµ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê ÎïåÎßå)
      let imageUrl: string | undefined;
      const shouldGenerateImage = !skipTyping && Math.random() > 0.5;
      
      if (shouldGenerateImage) {
        try {
          const { data: imageData } = await supabase.functions.invoke('generate-story-image', {
            body: {
              storyContext: storyContent,
              genre: selectedGenre,
              characterName: idol.name,
              characterGender: idol.gender || 'female'
            }
          });
          
          if (imageData?.imageUrl) {
            imageUrl = imageData.imageUrl;
          }
        } catch (imgError) {
          console.error('Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®:', imgError);
        }
      }

      const idolMessage: Message = {
        id: (Date.now() + 1).toString(),
        sender: 'idol',
        content: storyContent,
        timestamp: new Date(),
        emotion: detectEmotion(storyContent),
        choices: choices.length > 0 ? choices : undefined,
        imageUrl
      };

      setMessages(prev => [...prev, idolMessage]);
      await saveChatLog(idolMessage);
      
      // ÏùåÏÑ±Í≥º ÌÉÄÏù¥Ìïë Ìö®Í≥ºÎ•º ÎèôÏãúÏóê ÏãúÏûë
      const voicePromise = isVoiceMode ? playIdolVoice(storyContent) : Promise.resolve();
      const typePromise = typeMessage(storyContent);
      
      // Îëò Îã§ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ Í∏∞Îã§Î¶º (Î≥ëÎ†¨ Ï≤òÎ¶¨)
      await Promise.all([voicePromise, typePromise]);

      // Í¥ÄÍ≥Ñ Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏
      const positiveKeywords = ['Ï¢ãÏïÑ', 'ÏÇ¨Îûë', 'Î©ãÏûà', 'ÏòàÏÅò', 'ÏµúÍ≥†', 'Í≥†ÎßàÏõå', 'ÏùëÏõê'];
      const isPositive = positiveKeywords.some(kw => userMessage.content.includes(kw));
      if (isPositive) {
        const newScore = Math.min(100, relationshipScore + Math.floor(Math.random() * 5) + 2);
        saveRelationshipScore(newScore);
      }

    } catch (error) {
      console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
      toast.error("Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      
      // Ïã§Ìå®Ìïú Î©îÏãúÏßÄ ÌëúÏãú
      const errorMessage: Message = {
        id: (Date.now() + 2).toString(),
        sender: 'idol',
        content: userMessage.content,
        timestamp: new Date(),
        error: true
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };

  const retryMessage = async (messageContent: string) => {
    setInputMessage(messageContent);
    await sendMessage();
  };

  const detectEmotion = (text: string): 'happy' | 'excited' | 'shy' | 'neutral' => {
    if (text.includes('!') || text.includes('‚ô•') || text.includes('‚ù§')) return 'excited';
    if (text.includes('„Öé„Öé') || text.includes('üòä')) return 'happy';
    if (text.includes('...') || text.includes('üò≥')) return 'shy';
    return 'neutral';
  };

  const handleChoiceClick = async (choice: string) => {
    if (!choice.trim() || isTyping) return;

    // ÌäπÎ≥Ñ ÏÑ†ÌÉùÏßÄ Ï≤òÎ¶¨
    if (choice === 'ÏÑ±Ìñ• Î∂ÑÏÑù Í≤∞Í≥ºÎ≥¥Í∏∞') {
      if (demoAnalysis) {
        window.location.href = `/result-analysis?analysis=${encodeURIComponent(JSON.stringify(demoAnalysis))}`;
      }
      return;
    }
    
    if (choice === 'ÎÇòÏ§ëÏóê ÌïòÍ∏∞') {
      onClose();
      return;
    }

    // Ï≤¥ÌóòÌåê 11Î≤à Ï†úÌïú (user Î©îÏãúÏßÄÎßå Ïπ¥Ïö¥Ìä∏)
    const userMessageCount = messages.filter(m => m.sender === 'user').length;
    
    if (isDemoMode && userMessageCount >= 11) {
      toast.error("Ï≤¥ÌóòÌåêÏùÄ 11Î≤àÍπåÏßÄÎßå ÎåÄÌôîÌï† Ïàò ÏûàÏäµÎãàÎã§!");
      return;
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      sender: 'user',
      content: choice.trim(),
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage("");
    setIsTyping(true);
    setMessageCount(prev => prev + 1);
    setConversationCount(prev => prev + 1);

    await saveChatLog(userMessage);

    try {
      const conversationHistory = messages.slice(-10).map(m => ({
        role: m.sender === 'user' ? 'user' : 'assistant',
        content: m.content
      }));

      const genreInfo = GENRES.find(g => g.id === selectedGenre);
      const genreContext = genreInfo ? `
Ïû•Î•¥: ${genreInfo.name} ${genreInfo.emoji}
Ïû•Î•¥ ÏÑ§Ï†ï: ${genreInfo.description}` : '';

      const systemPrompt = `ÎÑàÎäî K-POP ÏïÑÏù¥Îèå ${idol.name}Ïïº.
ÏÑ±Í≤©: ${idol.personality}
${genreContext}

ÎÑàÎäî Ìå¨Ïù¥Îûë Ìï®Íªò Ïõπ ÏÜåÏÑ§ÏùÑ Ïì∞Í≥† ÏûàÏñ¥.
Í∑úÏπô:
1. Î∞òÎßêÎ°ú ÏπúÍµ¨Ï≤òÎüº Ìé∏ÌïòÍ≤å ÎåÄÌôîÌï¥
2. ÏûêÍ∑πÏ†ÅÏù¥Í≥† Ìù•ÎØ∏Î°úÏö¥ ÏÉÅÌô©ÏùÑ Í≥ÑÏÜç Ï†úÏãúÌï¥
3. ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÌï† Ïàò ÏûàÎäî 3Í∞ÄÏßÄ ÌñâÎèô ÏòµÏÖòÏùÑ Ï†úÏïàÌï¥
4. Í∞Å ÏòµÏÖòÏùÄ 30Ïûê Ïù¥ÎÇ¥Î°ú Í∞ÑÍ≤∞ÌïòÍ≤å
5. Í∏∞ÏäπÏ†ÑÍ≤∞ ÏóÜÏù¥ Í≥ÑÏÜç Í∏¥Ïû•Í∞ê ÏûàÎäî Ï†ÑÍ∞úÎ•º Ïú†ÏßÄÌï¥
6. 150Ïûê ÎÇ¥Ïô∏Î°ú ÏÉÅÌô© ÏÑ§Î™Ö
7. Î∞òÎìúÏãú Îã§Ïùå ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥:

[Ïù¥ÏïºÍ∏∞]
(Ïó¨Í∏∞Ïóê ÏÉÅÌô© Ï†ÑÍ∞ú)

[ÏÑ†ÌÉùÏßÄ]
1. (Ï≤´ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)
2. (Îëê Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)
3. (ÏÑ∏ Î≤àÏß∏ ÏÑ†ÌÉùÏßÄ)`;

      const { data, error } = await supabase.functions.invoke('generate-character-chat', {
        body: {
          prompt: `${systemPrompt}\n\nÎåÄÌôî Í∏∞Î°ù:\n${conversationHistory.map(m => `${m.role}: ${m.content}`).join('\n')}\n\nÌå¨: ${userMessage.content}\n\n${idol.name}:`
        }
      });

      if (error) throw error;

      const response = data.response || "ÎØ∏Ïïà... Ïû†Íπê ÏÉùÍ∞ÅÏù¥ Ïïà ÎÇòÎÑ§. Îã§Ïãú ÎßêÌï¥Ï§ÑÎûò? üòÖ";
      const storyMatch = response.match(/\[Ïù¥ÏïºÍ∏∞\]([\s\S]*?)(?:\[ÏÑ†ÌÉùÏßÄ\]|$)/);
      const choicesMatch = response.match(/\[ÏÑ†ÌÉùÏßÄ\]([\s\S]*)/);
      
      const storyContent = storyMatch ? storyMatch[1].trim() : response;
      const choices = choicesMatch 
        ? choicesMatch[1].split('\n')
            .map(c => c.replace(/^\d+\.\s*/, '').trim())
            .filter(c => c.length > 0)
        : [];

      // Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± (Ï∫êÎ¶≠ÌÑ∞ Ï†ïÎ≥¥ Ìè¨Ìï®, Ïä§ÌÇµ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãê ÎïåÎßå)
      let imageUrl: string | undefined;
      if (!skipTyping) {
        try {
          const { data: imageData } = await supabase.functions.invoke('generate-story-image', {
            body: {
              storyContext: storyContent,
              genre: selectedGenre,
              characterName: idol.name,
              characterGender: idol.gender || 'female'
            }
          });
          imageUrl = imageData?.imageUrl;
        } catch (imgError) {
          console.error('Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®:', imgError);
        }
      }

      const idolMessage: Message = {
        id: (Date.now() + 1).toString(),
        sender: 'idol',
        content: storyContent,
        timestamp: new Date(),
        emotion: detectEmotion(storyContent),
        choices: choices.length > 0 ? choices : undefined,
        imageUrl
      };

      setMessages(prev => [...prev, idolMessage]);
      await saveChatLog(idolMessage);
      
      // ÏùåÏÑ±Í≥º ÌÉÄÏù¥Ìïë Ìö®Í≥ºÎ•º ÎèôÏãúÏóê ÏãúÏûë
      const voicePromise = isVoiceMode ? playIdolVoice(storyContent) : Promise.resolve();
      const typePromise = typeMessage(storyContent);
      
      // Îëò Îã§ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ Í∏∞Îã§Î¶º (Î≥ëÎ†¨ Ï≤òÎ¶¨)
      await Promise.all([voicePromise, typePromise]);

      // Í¥ÄÍ≥Ñ Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏
      const positiveKeywords = ['Ï¢ãÏïÑ', 'ÏÇ¨Îûë', 'Î©ãÏûà', 'ÏòàÏÅò', 'ÏµúÍ≥†', 'Í≥†ÎßàÏõå', 'ÏùëÏõê'];
      const isPositive = positiveKeywords.some(kw => userMessage.content.includes(kw));
      if (isPositive) {
        const newScore = Math.min(100, relationshipScore + Math.floor(Math.random() * 5) + 2);
        saveRelationshipScore(newScore);
      }

      // ÏÑ†ÌÉùÏßÄ Ï†ÄÏû•
      if (choices.length > 0) {
        setSelectedChoices(prev => [...prev, userMessage.content]);
      }

      // 11Î≤àÏùò user Î©îÏãúÏßÄÍ∞Ä ÏôÑÎ£åÎêòÎ©¥ Î∂ÑÏÑù ÏãúÏûë
      const currentUserMessageCount = messages.filter(m => m.sender === 'user').length + 1; // +1 for current message
      
      if (currentUserMessageCount === 11 && isDemoMode && !isAnalyzing) {
        setIsAnalyzing(true);
        
        // Î∂ÑÏÑù ÏãúÏûë
        setTimeout(async () => {
          try {
            const chatMessages = messages.concat([userMessage, idolMessage]).map(m => ({
              role: m.sender === 'user' ? 'user' : 'assistant',
              content: m.content
            }));

            const { data, error } = await supabase.functions.invoke('analyze-conversation', {
              body: {
                messages: chatMessages,
                choices: selectedChoices
              }
            });

            if (error) {
              console.error('ÎåÄÌôî Î∂ÑÏÑù Ïã§Ìå®:', error);
              // Î∂ÑÏÑù Ïã§Ìå®Ìï¥ÎèÑ Í∏∞Î≥∏ ÏÑ±Ìñ• Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
              const defaultPersonality = {
                type: 'ISFP',
                traits: ['ÏòàÏà†Ï†Å', 'ÏûêÏú†Î°úÏö¥', 'Í∞êÏÑ±Ï†Å'],
                description: 'Í∞êÏÑ±Ï†ÅÏù¥Í≥† ÏûêÏú†Î°úÏö¥ ÏòÅÌòºÏùÑ Í∞ÄÏßÑ Ìå¨'
              };
              localStorage.setItem('personalityProfile', JSON.stringify(defaultPersonality));
              setDemoAnalysis(defaultPersonality);
              toast.success("ÎåÄÌôî Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!");
              return;
            }

            const result = data.analysis;
            setDemoAnalysis(result); // Î∂ÑÏÑù Í≤∞Í≥º Ï†ÄÏû•
            
            const summaryContent = `[Ï≤¥Ìóò ÏôÑÎ£å! üéâ]\n\n${userName}ÎãòÏùò ÌïµÏã¨ ÏÑ±Ìñ•: ${result.personality || 'ÎãπÏã†Ïùò Ï∑®Ìñ•ÏùÑ Î∂ÑÏÑùÌñàÏñ¥Ïöî.'}\n\nÏ∂îÏ≤ú ÏïÑÏù¥Îèå:\n‚Ä¢ ÎÇ®Ïûê: ${result.maleIdol?.name || 'ÎÇ®Ïûê ÏïÑÏù¥Îèå'} (${result.maleIdol?.mbti || ''})\n‚Ä¢ Ïó¨Ïûê: ${result.femaleIdol?.name || 'Ïó¨Ïûê ÏïÑÏù¥Îèå'} (${result.femaleIdol?.mbti || ''})`;

            const analysisMessage: Message = {
              id: (Date.now() + 100).toString(),
              sender: 'idol',
              content: summaryContent,
              timestamp: new Date(),
              emotion: 'excited'
            };

            setMessages(prev => [...prev, analysisMessage]);

            // ÏÑ±Ìñ• Î∂ÑÏÑù Í≤∞Í≥ºÎ≥¥Í∏∞ Ïú†ÎèÑ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
            setTimeout(() => {
              const loginPromptMessage: Message = {
                id: (Date.now() + 200).toString(),
                sender: 'idol',
                content: 'Îçî ÏûêÏÑ∏Ìïú ÏÑ±Ìñ• Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÍ≥† Ïã∂ÏúºÏã†Í∞ÄÏöî?',
                timestamp: new Date(),
                emotion: 'excited',
                choices: ['ÏÑ±Ìñ• Î∂ÑÏÑù Í≤∞Í≥ºÎ≥¥Í∏∞', 'ÎÇòÏ§ëÏóê ÌïòÍ∏∞']
              };
              setMessages(prev => [...prev, loginPromptMessage]);
            }, 1000);

          } catch (error) {
            console.error('Î∂ÑÏÑù Ïã§Ìå®:', error);
            toast.error("Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
          } finally {
            setIsAnalyzing(false);
          }
        }, 500);
      }

    } catch (error) {
      console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
      toast.error("Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      
      // Ïã§Ìå®Ìïú Î©îÏãúÏßÄ ÌëúÏãú
      const errorMessage: Message = {
        id: (Date.now() + 2).toString(),
        sender: 'idol',
        content: userMessage.content,
        timestamp: new Date(),
        error: true
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  };
  
  // ÌÉÄÏù¥Ìïë Ìö®Í≥º Ìï®Ïàò
  const typeMessage = async (text: string) => {
    return new Promise<void>((resolve) => {
      setIsTypingEffect(true);
      setTypingText('');
      setSkipTyping(false);
      let currentIndex = 0;
      
      const typeNextChar = () => {
        // Ïä§ÌÇµ ÏöîÏ≤≠ Ïãú Ï¶âÏãú Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏ ÌëúÏãú
        if (skipTyping) {
          setTypingText(text);
          setIsTypingEffect(false);
          if (typingTimeoutRef.current) {
            clearTimeout(typingTimeoutRef.current);
          }
          resolve();
          return;
        }

        if (currentIndex < text.length) {
          setTypingText(text.substring(0, currentIndex + 1));
          currentIndex++;
          
          // ÌÉÄÏù¥Ìïë ÏÇ¨Ïö¥Îìú (ÏÑ†ÌÉùÏ†Å)
          if (Math.random() > 0.7) {
            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZRA0PVqzn7q9cGAc/mdvzw3IlBSyBzvLYiTcIGWi77eefTRAMUKfj8LZjHAY4ktfyzHksBSR3x/DdkEAKFF606+uoVRQKRp/g8r5sIQUxh9Hz04IzBh5uwO/jmUQND1as5+6vXBgHP5nb88NyJQUsga2MYmJmiImNdGpdXGddaG5qZmRdYFhYXFxYWFxaYmNgZWhmY2VkZGJiY2RkY2NjY2RjZGRkZGNjY2RkZGRkZGRkZGRkZGRkZGRkZGRkZGRlY2JiY2JiYmNiYmJiY2NiYmNjY2NjY2NiY2NkZGNiY2NiY2NlY2RjY2NjY2NjY2NjY2NjY2NjY2NjY2NiYmNjY2NjY2NjY2NjY2NjY2NjY2RjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2Ni');
            audio.volume = 0.1;
            audio.play().catch(() => {});
          }
          
          typingTimeoutRef.current = setTimeout(typeNextChar, 30);
        } else {
          setIsTypingEffect(false);
          resolve();
        }
      };
      
      typeNextChar();
    });
  };

  const playIdolVoice = async (text: string) => {
    try {
      // ÌÖåÏä§Ìä∏Ïö© ÏßÄÏö∞ Î≥¥Ïù¥Ïä§ ID
      const voiceId = idol.voiceId || 'DMkRitQrfpiddSQT5adl';
      
      console.log('üé§ Using voice ID:', voiceId);
      console.log('üé§ Text to speak:', text);
      
      const { data, error } = await supabase.functions.invoke('text-to-speech', {
        body: {
          text,
          voice: voiceId
        }
      });

      if (error) {
        console.error('‚ùå TTS Error:', error);
        throw error;
      }
      
      console.log('‚úÖ TTS Response received');

      if (data?.audioContent) {
        const audioBlob = new Blob(
          [Uint8Array.from(atob(data.audioContent), c => c.charCodeAt(0))],
          { type: 'audio/mpeg' }
        );
        const audioUrl = URL.createObjectURL(audioBlob);
        
        if (audioRef.current) {
          audioRef.current.src = audioUrl;
          await audioRef.current.play();
        }
      }
    } catch (error) {
      console.error('ÏùåÏÑ± Ïû¨ÏÉù Ïã§Ìå®:', error);
    }
  };

  const toggleVoiceMode = () => {
    setIsVoiceMode(!isVoiceMode);
    if (!isVoiceMode) {
      toast.success("Ï∫êÎ¶≠ÌÑ∞ ÏùåÏÑ± Î™®ÎìúÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§!");
      if (!audioRef.current) {
        audioRef.current = new Audio();
      }
    } else {
      toast("ÏùåÏÑ± Î™®ÎìúÍ∞Ä ÎπÑÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.");
      if (audioRef.current) {
        audioRef.current.pause();
      }
    }
  };

  if (!isOpen) return null;

  return (
    <>
    <div className="fixed inset-0 z-50 flex items-center justify-center p-2 bg-black">
      {/* MUD Í≤åÏûÑ ÌÑ∞ÎØ∏ÎÑê - Î™®Î∞îÏùº ÏÑ∏Î°ú ÏÇ¨Ïù¥Ï¶à */}
      <div className="relative w-full max-w-md h-[90vh]">
        <div className="relative p-2 bg-gray-900 h-full">
          <div className="relative h-full">
            <Card className="w-full h-full flex flex-col bg-black border border-blue-600 rounded-none relative overflow-hidden">
              {/* ÎØ∏ÏÑ∏Ìïú Ïä§Ï∫îÎùºÏù∏ */}
              <div className="absolute inset-0 pointer-events-none z-10 opacity-10" style={{
                backgroundImage: 'repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(255,255,255,0.02) 1px, rgba(255,255,255,0.02) 2px)',
              }} />

          {/* Ìó§Îçî - MUD Ïä§ÌÉÄÏùº */}
          <div className="relative z-20 border-b border-blue-600 bg-black">
            {/* ÏÉÅÎã® Í≥†Ï†ï: Î≤ÑÌäºÎì§ */}
            <div className="flex items-center justify-end gap-2 px-3 py-2 border-b border-blue-900">
              <Button
                variant="ghost"
                size="sm"
                onClick={toggleVoiceMode}
                className={`border p-2 text-xs ${isVoiceMode ? "border-blue-600 bg-blue-600 text-white" : "border-blue-600 text-blue-600 hover:bg-blue-600 hover:text-white"}`}
              >
                {isVoiceMode ? <Mic className="w-4 h-4" /> : <MicOff className="w-4 h-4" />}
              </Button>
              <Button 
                variant="ghost" 
                size="sm" 
                onClick={onClose} 
                className="border border-gray-600 text-gray-400 hover:bg-gray-600 hover:text-white p-2"
              >
                <X className="w-4 h-4" />
              </Button>
            </div>
            
            {/* Ï∫êÎ¶≠ÌÑ∞ Ï†ïÎ≥¥ */}
            <div className="flex items-center gap-3 px-4 py-2">
              <div className="w-12 h-12 border border-blue-600 p-0.5 bg-black flex-shrink-0">
                <img src={idol.image} alt={idol.name} className="w-full h-full object-cover grayscale" />
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 mb-1 flex-wrap">
                  <h3 className="font-mono text-sm text-white uppercase tracking-wide">{idol.name}</h3>
                  {selectedGenre && (
                    <span className="text-xs font-mono bg-blue-600 text-white px-2 py-0.5">
                      {GENRES.find(g => g.id === selectedGenre)?.name}
                    </span>
                  )}
                </div>
                <p className="text-xs text-gray-500 font-mono mb-1 truncate">{idol.personality}</p>
                <div className="flex items-center gap-2 flex-wrap">
                  <span className="text-white text-xs font-mono">REL:</span>
                  <div className="w-20 sm:w-24 bg-gray-900 border border-blue-600 h-2">
                    <div 
                      className="bg-blue-600 h-full transition-all duration-500"
                      style={{ width: `${relationshipScore}%` }}
                    />
                  </div>
                  <span className="text-xs text-white font-mono">{relationshipScore}%</span>
                  {isDemoMode && (
                    <span className="text-xs text-blue-400 font-mono">
                      [{messageCount}/11]
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Î©îÏãúÏßÄ ÏòÅÏó≠ - MUD Ïä§ÌÉÄÏùº */}
          <ScrollArea className="relative z-20 flex-1 p-4 bg-black">
            <div className="space-y-2 font-mono text-sm">
            {messages.map((msg, index) => (
              <div
                key={msg.id}
                className={`flex ${msg.sender === 'user' ? 'justify-end' : 'justify-center'} animate-fade-in glitch-on-appear`}
                style={{ animationDelay: `${index * 0.05}s` }}
              >
                <div className={`space-y-1 ${msg.sender === 'user' ? 'max-w-[80%]' : 'w-full flex flex-col items-center'}`}>
                  {msg.imageUrl && msg.sender === 'idol' && !msg.error && (
                    <div className="w-full max-w-[340px] mb-1">
                      <img 
                        src={msg.imageUrl} 
                        alt="Story scene" 
                        className="w-full h-auto object-contain grayscale contrast-125 brightness-110"
                      />
                    </div>
                  )}
                  <div className="p-0">
                    {msg.error ? (
                      <div className="flex items-start gap-2">
                        <span className="text-red-500 text-xs">{'>'} ERROR:</span>
                        <p className="text-red-500 text-xs flex-1">{msg.content}</p>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => retryMessage(msg.content)}
                          className="border border-red-500 text-red-500 hover:bg-red-500 hover:text-white h-6 px-2 text-xs"
                        >
                          RETRY
                        </Button>
                      </div>
                    ) : (
                      <>
                        {msg.sender === 'idol' ? (
                          <p className="text-white text-sm leading-relaxed whitespace-pre-line">
                            <span className="text-blue-400">{'> '}</span>
                            {msg.sender === 'idol' && index === messages.length - 1 && isTypingEffect
                              ? typingText
                              : msg.content}
                            {msg.sender === 'idol' && index === messages.length - 1 && isTypingEffect && (
                              <span className="inline-block w-1.5 h-3 bg-white ml-1 animate-pulse" />
                            )}
                          </p>
                        ) : (
                          <p className="text-blue-300 text-sm leading-relaxed whitespace-pre-line">
                            <span className="text-blue-600">{'< '}</span>
                            {msg.content}
                          </p>
                        )}
                        <p className="text-xs text-gray-700 mt-0.5 ml-2">
                          [{msg.timestamp.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}]
                        </p>
                      </>
                    )}
                  </div>
                </div>
              </div>
            ))}

            {/* ÏÑ†ÌÉùÏßÄ ÌëúÏãú - MUD Ïä§ÌÉÄÏùº */}
            {messages.length > 0 && messages[messages.length - 1].sender === 'idol' && messages[messages.length - 1].choices && !isTypingEffect && (
              <div className="flex justify-start mt-2">
                <div className="flex flex-col gap-1 w-full">
                  {messages[messages.length - 1].choices!.map((choice, idx) => (
                    <button
                      key={idx}
                      onClick={() => handleChoiceClick(choice)}
                      className="text-left hover:text-white transition-colors font-mono text-sm text-blue-400 hover:bg-blue-900/20 p-1"
                    >
                      [{idx + 1}] {choice}
                    </button>
                  ))}
                </div>
              </div>
            )}
            
            {/* Ïû•Î•¥ ÏÑ†ÌÉù Î≤ÑÌäº - MUD Ïä§ÌÉÄÏùº */}
            {showGenreSelect && (
              <div className="border-t border-blue-600 pt-3 mt-3">
                <p className="text-blue-400 text-sm mb-2 font-mono">üìö GENRE:</p>
                <div className="grid grid-cols-2 gap-1">
                  {GENRES.map((genre, idx) => (
                    <button
                      key={genre.id}
                      onClick={() => handleGenreSelect(genre.id as GenreType)}
                      className="text-left transition-all p-2 text-blue-400 hover:text-white hover:bg-blue-900/20"
                    >
                      <div className="font-mono text-xs">
                        <div className="font-bold">[{idx + 1}] {genre.emoji} {genre.name}</div>
                        <div className="opacity-70 text-[10px]">{genre.description}</div>
                      </div>
                    </button>
                  ))}
                </div>
              </div>
            )}
            
            {isTyping && !isTypingEffect && (
              <div className="flex justify-start">
                <div className="p-1 text-white">
                  <div className="flex space-x-1 items-center">
                    <span className="text-blue-400 text-sm">{'>'}</span>
                    <div className="w-1.5 h-1.5 bg-white animate-bounce" />
                    <div className="w-1.5 h-1.5 bg-white animate-bounce" style={{ animationDelay: '0.1s' }} />
                    <div className="w-1.5 h-1.5 bg-white animate-bounce" style={{ animationDelay: '0.2s' }} />
                  </div>
                </div>
              </div>
            )}
            <div ref={messagesEndRef} />
            </div>
          </ScrollArea>

          <div className="relative z-20 px-4 py-3 border-t border-blue-600 bg-black">
            {isDemoMode && messageCount >= 11 ? (
              <div className="text-center space-y-2">
                <p className="text-sm font-mono text-white">Ï≤¥ÌóòÌåê Ï¢ÖÎ£å [11/11]</p>
                <p className="text-xs font-mono text-gray-500">ÏßÄÍ∞ë Ïó∞Í≤∞ÌïòÎ©¥ Í≥ÑÏÜç ÎåÄÌôî Í∞ÄÎä•</p>
                <Button
                  className="bg-blue-600 hover:bg-blue-500 text-white font-mono text-xs mt-2 border border-blue-600"
                  onClick={() => window.location.href = '/auth'}
                >
                  <Wallet className="w-3 h-3 mr-1" />
                  ÏßÄÍ∞ë Ïó∞Í≤∞
                </Button>
              </div>
            ) : (
              <>
                <div className="flex gap-2">
                  <Input
                    value={inputMessage}
                    onChange={(e) => setInputMessage(e.target.value)}
                    placeholder={selectedGenre ? "C:\\> " : "C:\\> Ïû•Î•¥ ÏÑ†ÌÉù ÌïÑÏöî"}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter' && !isTyping && selectedGenre) {
                        sendMessage();
                      }
                    }}
                    className="flex-1 bg-black border border-blue-600 text-white placeholder:text-gray-700 font-mono text-sm"
                    disabled={isTyping || !selectedGenre}
                  />
                  <Button 
                    onClick={sendMessage} 
                    disabled={isTyping || !inputMessage.trim() || !selectedGenre}
                    className="bg-blue-600 hover:bg-blue-500 text-white font-mono text-xs px-4 border border-blue-600"
                  >
                    <Send className="w-3 h-3" />
                  </Button>
                </div>
                <p className="text-[10px] text-gray-700 mt-2 text-center font-mono">
                  AI ÌïôÏäµÏúºÎ°ú {idol.name} ÎßûÏ∂§ ÏÉùÏÑ±
                </p>
              </>
            )}
          </div>
          
          {/* Ï†ÑÏõê LED */}
          <div className="absolute top-1 right-1">
            <div className="w-2 h-2 rounded-full bg-blue-400 animate-pulse" />
          </div>
            </Card>
          </div>
        </div>
      </div>
      
      {/* Ïù¥Î¶ÑÍ≥º ÏÑ±Î≥Ñ ÏûÖÎ†• Î™®Îã¨ */}
      {showNameInput && isDemoMode && (
        <div className="fixed inset-0 z-[60] bg-black/70 backdrop-blur-sm flex items-center justify-center p-4">
          <Card className="w-full max-w-md p-8 bg-white/95 backdrop-blur-md relative">
            {/* Îã´Í∏∞ Î≤ÑÌäº */}
            <Button
              variant="ghost"
              size="sm"
              onClick={onClose}
              className="absolute top-3 right-3 text-gray-500 hover:text-gray-700"
            >
              <X className="w-5 h-5" />
            </Button>
            
            <div className="text-center mb-6">
              <h2 className="text-2xl font-bold text-purple-900 mb-2">
                {idol.name}ÏôÄÏùò ÎåÄÌôî ÏãúÏûë ‚ú®
              </h2>
              <p className="text-gray-600">
                Ïù¥Î¶ÑÍ≥º ÏÑ±Î≥ÑÏùÑ ÏûÖÎ†•ÌïòÎ©¥ Îçî ÎßûÏ∂§Ìòï ÎåÄÌôîÎ•º ÎÇòÎàå Ïàò ÏûàÏñ¥Ïöî
              </p>
            </div>
            <form onSubmit={(e) => {
              e.preventDefault();
              const form = e.target as HTMLFormElement;
              const nameInput = form.elements.namedItem('name') as HTMLInputElement;
              if (nameInput.value.trim() && userGender) {
                setUserName(nameInput.value.trim());
                setShowNameInput(false);
              } else {
                toast.error('Ïù¥Î¶ÑÍ≥º ÏÑ±Î≥ÑÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!');
              }
            }}>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Ïù¥Î¶Ñ
                  </label>
                  <Input
                    name="name"
                    placeholder="Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
                    maxLength={20}
                    autoFocus
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    ÏÑ±Î≥Ñ
                  </label>
                  <div className="flex gap-4">
                    <Button
                      type="button"
                      variant={userGender === 'male' ? 'default' : 'outline'}
                      className="flex-1"
                      onClick={() => setUserGender('male')}
                    >
                      ÎÇ®ÏÑ±
                    </Button>
                    <Button
                      type="button"
                      variant={userGender === 'female' ? 'default' : 'outline'}
                      className="flex-1"
                      onClick={() => setUserGender('female')}
                    >
                      Ïó¨ÏÑ±
                    </Button>
                  </div>
                </div>
              </div>
              <Button type="submit" className="w-full mt-6">
                ÎåÄÌôî ÏãúÏûëÌïòÍ∏∞
              </Button>
            </form>
          </Card>
        </div>
      )}
    </div>
    </>
  );
};